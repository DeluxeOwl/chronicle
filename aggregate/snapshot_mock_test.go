// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package aggregate_test

import (
	"context"
	"github.com/DeluxeOwl/chronicle/aggregate"
	"sync"
)

// SnapshotStoreMock is a mock implementation of aggregate.SnapshotStore.
//
//	func TestSomethingThatUsesSnapshotStore(t *testing.T) {
//
//		// make and configure a mocked aggregate.SnapshotStore
//		mockedSnapshotStore := &SnapshotStoreMock{
//			GetSnapshotFunc: func(ctx context.Context, aggregateID TID) (TS, bool, error) {
//				panic("mock out the GetSnapshot method")
//			},
//			SaveSnapshotFunc: func(ctx context.Context, snapshot TS) error {
//				panic("mock out the SaveSnapshot method")
//			},
//		}
//
//		// use mockedSnapshotStore in code that requires aggregate.SnapshotStore
//		// and then make assertions.
//
//	}
type SnapshotStoreMock[TID aggregate.ID, TS aggregate.Snapshot[TID]] struct {
	// GetSnapshotFunc mocks the GetSnapshot method.
	GetSnapshotFunc func(ctx context.Context, aggregateID TID) (TS, bool, error)

	// SaveSnapshotFunc mocks the SaveSnapshot method.
	SaveSnapshotFunc func(ctx context.Context, snapshot TS) error

	// calls tracks calls to the methods.
	calls struct {
		// GetSnapshot holds details about calls to the GetSnapshot method.
		GetSnapshot []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AggregateID is the aggregateID argument value.
			AggregateID TID
		}
		// SaveSnapshot holds details about calls to the SaveSnapshot method.
		SaveSnapshot []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Snapshot is the snapshot argument value.
			Snapshot TS
		}
	}
	lockGetSnapshot  sync.RWMutex
	lockSaveSnapshot sync.RWMutex
}

// GetSnapshot calls GetSnapshotFunc.
func (mock *SnapshotStoreMock[TID, TS]) GetSnapshot(ctx context.Context, aggregateID TID) (TS, bool, error) {
	if mock.GetSnapshotFunc == nil {
		panic("SnapshotStoreMock.GetSnapshotFunc: method is nil but SnapshotStore.GetSnapshot was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		AggregateID TID
	}{
		Ctx:         ctx,
		AggregateID: aggregateID,
	}
	mock.lockGetSnapshot.Lock()
	mock.calls.GetSnapshot = append(mock.calls.GetSnapshot, callInfo)
	mock.lockGetSnapshot.Unlock()
	return mock.GetSnapshotFunc(ctx, aggregateID)
}

// GetSnapshotCalls gets all the calls that were made to GetSnapshot.
// Check the length with:
//
//	len(mockedSnapshotStore.GetSnapshotCalls())
func (mock *SnapshotStoreMock[TID, TS]) GetSnapshotCalls() []struct {
	Ctx         context.Context
	AggregateID TID
} {
	var calls []struct {
		Ctx         context.Context
		AggregateID TID
	}
	mock.lockGetSnapshot.RLock()
	calls = mock.calls.GetSnapshot
	mock.lockGetSnapshot.RUnlock()
	return calls
}

// SaveSnapshot calls SaveSnapshotFunc.
func (mock *SnapshotStoreMock[TID, TS]) SaveSnapshot(ctx context.Context, snapshot TS) error {
	if mock.SaveSnapshotFunc == nil {
		panic("SnapshotStoreMock.SaveSnapshotFunc: method is nil but SnapshotStore.SaveSnapshot was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Snapshot TS
	}{
		Ctx:      ctx,
		Snapshot: snapshot,
	}
	mock.lockSaveSnapshot.Lock()
	mock.calls.SaveSnapshot = append(mock.calls.SaveSnapshot, callInfo)
	mock.lockSaveSnapshot.Unlock()
	return mock.SaveSnapshotFunc(ctx, snapshot)
}

// SaveSnapshotCalls gets all the calls that were made to SaveSnapshot.
// Check the length with:
//
//	len(mockedSnapshotStore.SaveSnapshotCalls())
func (mock *SnapshotStoreMock[TID, TS]) SaveSnapshotCalls() []struct {
	Ctx      context.Context
	Snapshot TS
} {
	var calls []struct {
		Ctx      context.Context
		Snapshot TS
	}
	mock.lockSaveSnapshot.RLock()
	calls = mock.calls.SaveSnapshot
	mock.lockSaveSnapshot.RUnlock()
	return calls
}
